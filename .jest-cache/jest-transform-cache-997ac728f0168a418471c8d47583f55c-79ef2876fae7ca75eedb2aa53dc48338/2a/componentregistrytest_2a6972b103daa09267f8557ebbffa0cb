d46a23648ec7913dc8c6630e06c66182
/**
 * MCP Component Registry Integration Tests
 * Tests Level 4: Integration Safety via MCP server
 */

const MCPHelper = require('../../utils/mcp-helper');
describe('MCP Component Registry - Level 4 Integration', () => {
  let mcp;
  beforeAll(async () => {
    mcp = new MCPHelper('localhost', 3000);

    // Wait for MCP server to be ready
    try {
      await mcp.waitForServer(5000);
    } catch (error) {
      console.warn('⚠️  MCP server not running. Start it with: cd .system/mcp-servers && node component-registry.js');
      console.warn('⚠️  Skipping MCP integration tests');
    }
  });
  describe('Server Connectivity', () => {
    test('should connect to MCP server', async () => {
      const isRunning = await mcp.isServerRunning();
      if (!isRunning) {
        console.log('⏭️  Skipping test - MCP server not available');
        return;
      }
      expect(isRunning).toBe(true);
    });
  });
  describe('Component Registration', () => {
    test('should register component successfully', async () => {
      if (!(await mcp.isServerRunning())) {
        console.log('⏭️  Skipping test - MCP server not available');
        return;
      }
      const component = mcp.createMockComponent('test-button', {
        cssNamespace: '.component-test-button-',
        jsAPI: ['TestButton.init', 'TestButton.destroy'],
        dependencies: [],
        events: ['button-clicked']
      });
      const result = await mcp.registerComponent(component);
      expect(result.success).toBe(true);
      expect(result.componentName).toBe('test-button');
    });
    test('should list registered components', async () => {
      if (!(await mcp.isServerRunning())) {
        console.log('⏭️  Skipping test - MCP server not available');
        return;
      }
      const result = await mcp.listComponents();
      expect(result).toBeDefined();
      expect(Array.isArray(result.components) || typeof result.components === 'object').toBe(true);
    });
  });
  describe('Conflict Detection', () => {
    test('should detect CSS namespace conflicts', async () => {
      if (!(await mcp.isServerRunning())) {
        console.log('⏭️  Skipping test - MCP server not available');
        return;
      }

      // Register first component
      const component1 = mcp.createMockComponent('button-primary', {
        cssNamespace: '.component-button-',
        jsAPI: ['ButtonPrimary.init']
      });
      await mcp.registerComponent(component1);

      // Try to register second component with same namespace
      const component2 = mcp.createMockComponent('button-secondary', {
        cssNamespace: '.component-button-',
        // CONFLICT!
        jsAPI: ['ButtonSecondary.init']
      });
      const validation = await mcp.validateIntegration(component2.name);

      // Should detect the conflict
      expect(validation.hasConflicts || validation.success === false).toBe(true);
    });
    test('should detect JavaScript API conflicts', async () => {
      if (!(await mcp.isServerRunning())) {
        console.log('⏭️  Skipping test - MCP server not available');
        return;
      }

      // Register component with specific JS API
      const component1 = mcp.createMockComponent('form-validator', {
        cssNamespace: '.component-form-validator-',
        jsAPI: ['FormValidator.validate', 'FormValidator.reset']
      });
      await mcp.registerComponent(component1);

      // Try to register another component with overlapping API
      const component2 = mcp.createMockComponent('form-helper', {
        cssNamespace: '.component-form-helper-',
        jsAPI: ['FormValidator.validate'] // CONFLICT!
      });
      const validation = await mcp.validateIntegration(component2.name);

      // Should detect the API conflict
      expect(validation.hasConflicts || validation.success === false).toBe(true);
    });
    test('should allow non-conflicting components', async () => {
      if (!(await mcp.isServerRunning())) {
        console.log('⏭️  Skipping test - MCP server not available');
        return;
      }
      const component1 = mcp.createMockComponent('modal-dialog', {
        cssNamespace: '.component-modal-dialog-',
        jsAPI: ['ModalDialog.open', 'ModalDialog.close']
      });
      await mcp.registerComponent(component1);
      const component2 = mcp.createMockComponent('tooltip-helper', {
        cssNamespace: '.component-tooltip-helper-',
        jsAPI: ['TooltipHelper.show', 'TooltipHelper.hide']
      });
      const validation = await mcp.validateIntegration(component2.name);

      // Should NOT have conflicts
      expect(validation.success).toBe(true);
    });
  });
  describe('Integration Plan', () => {
    test('should generate integration plan for component', async () => {
      if (!(await mcp.isServerRunning())) {
        console.log('⏭️  Skipping test - MCP server not available');
        return;
      }
      const component = mcp.createMockComponent('alert-banner', {
        cssNamespace: '.component-alert-banner-',
        jsAPI: ['AlertBanner.show', 'AlertBanner.dismiss']
      });
      await mcp.registerComponent(component);
      const plan = await mcp.getIntegrationPlan(component.name);
      expect(plan).toBeDefined();
      expect(plan.componentName || plan.component).toBe(component.name);
    });
  });
  describe('Contract Validation', () => {
    test('should validate contract compliance', async () => {
      if (!(await mcp.isServerRunning())) {
        console.log('⏭️  Skipping test - MCP server not available');
        return;
      }
      const contractPath = '.system/contracts/example-button-contract.md';
      const implementationPath = 'tests/fixtures/button-component-mock.js';
      const result = await mcp.validateContract(contractPath, implementationPath);
      expect(result).toBeDefined();
      // MCP should validate that implementation matches contract
    });
  });
  describe('Preflight Checks', () => {
    test('should run all 4 validation levels', async () => {
      if (!(await mcp.isServerRunning())) {
        console.log('⏭️  Skipping test - MCP server not available');
        return;
      }
      const component = mcp.createMockComponent('dropdown-menu', {
        cssNamespace: '.component-dropdown-menu-',
        jsAPI: ['DropdownMenu.toggle']
      });
      await mcp.registerComponent(component);
      const checks = await mcp.runPreflightChecks(component.name);
      expect(checks).toBeDefined();
      if (checks.levels) {
        // Verify all 4 levels are checked
        expect(checks.levels).toHaveProperty('level1'); // Syntax
        expect(checks.levels).toHaveProperty('level2'); // Unit Tests
        expect(checks.levels).toHaveProperty('level3'); // Contract
        expect(checks.levels).toHaveProperty('level4'); // Integration
      }
    });
  });
  describe('Sandbox Testing', () => {
    test('should check sandbox test status', async () => {
      if (!(await mcp.isServerRunning())) {
        console.log('⏭️  Skipping test - MCP server not available');
        return;
      }
      const component = mcp.createMockComponent('carousel-slider');
      await mcp.registerComponent(component);
      const sandboxResult = await mcp.testInSandbox(component.name);
      expect(sandboxResult).toBeDefined();
    });
  });
  describe('Component Lifecycle', () => {
    test('should mark component as proven after validation', async () => {
      if (!(await mcp.isServerRunning())) {
        console.log('⏭️  Skipping test - MCP server not available');
        return;
      }
      const component = mcp.createMockComponent('status-badge', {
        cssNamespace: '.component-status-badge-',
        status: 'validated'
      });
      await mcp.registerComponent(component);
      const result = await mcp.markAsProven(component.name);
      expect(result).toBeDefined();
      expect(result.success || result.status === 'proven').toBe(true);
    });
  });
  describe('Example Button Contract - MCP Integration', () => {
    test('should register example-button without conflicts', async () => {
      if (!(await mcp.isServerRunning())) {
        console.log('⏭️  Skipping test - MCP server not available');
        return;
      }
      const exampleButton = {
        name: 'example-button',
        cssNamespace: '.component-example-button-',
        jsAPI: ['ExampleButton.getCount', 'ExampleButton.reset', 'ExampleButton.destroy'],
        dependencies: [],
        events: ['button-clicked'],
        status: 'development'
      };
      const registration = await mcp.registerComponent(exampleButton);
      expect(registration.success).toBe(true);
      const validation = await mcp.validateIntegration(exampleButton.name);
      expect(validation.success).toBe(true);
    });
  });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJNQ1BIZWxwZXIiLCJyZXF1aXJlIiwiZGVzY3JpYmUiLCJtY3AiLCJiZWZvcmVBbGwiLCJ3YWl0Rm9yU2VydmVyIiwiZXJyb3IiLCJjb25zb2xlIiwid2FybiIsInRlc3QiLCJpc1J1bm5pbmciLCJpc1NlcnZlclJ1bm5pbmciLCJsb2ciLCJleHBlY3QiLCJ0b0JlIiwiY29tcG9uZW50IiwiY3JlYXRlTW9ja0NvbXBvbmVudCIsImNzc05hbWVzcGFjZSIsImpzQVBJIiwiZGVwZW5kZW5jaWVzIiwiZXZlbnRzIiwicmVzdWx0IiwicmVnaXN0ZXJDb21wb25lbnQiLCJzdWNjZXNzIiwiY29tcG9uZW50TmFtZSIsImxpc3RDb21wb25lbnRzIiwidG9CZURlZmluZWQiLCJBcnJheSIsImlzQXJyYXkiLCJjb21wb25lbnRzIiwiY29tcG9uZW50MSIsImNvbXBvbmVudDIiLCJ2YWxpZGF0aW9uIiwidmFsaWRhdGVJbnRlZ3JhdGlvbiIsIm5hbWUiLCJoYXNDb25mbGljdHMiLCJwbGFuIiwiZ2V0SW50ZWdyYXRpb25QbGFuIiwiY29udHJhY3RQYXRoIiwiaW1wbGVtZW50YXRpb25QYXRoIiwidmFsaWRhdGVDb250cmFjdCIsImNoZWNrcyIsInJ1blByZWZsaWdodENoZWNrcyIsImxldmVscyIsInRvSGF2ZVByb3BlcnR5Iiwic2FuZGJveFJlc3VsdCIsInRlc3RJblNhbmRib3giLCJzdGF0dXMiLCJtYXJrQXNQcm92ZW4iLCJleGFtcGxlQnV0dG9uIiwicmVnaXN0cmF0aW9uIl0sInNvdXJjZXMiOlsiY29tcG9uZW50LXJlZ2lzdHJ5LnRlc3QuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBNQ1AgQ29tcG9uZW50IFJlZ2lzdHJ5IEludGVncmF0aW9uIFRlc3RzXG4gKiBUZXN0cyBMZXZlbCA0OiBJbnRlZ3JhdGlvbiBTYWZldHkgdmlhIE1DUCBzZXJ2ZXJcbiAqL1xuXG5jb25zdCBNQ1BIZWxwZXIgPSByZXF1aXJlKCcuLi8uLi91dGlscy9tY3AtaGVscGVyJyk7XG5cbmRlc2NyaWJlKCdNQ1AgQ29tcG9uZW50IFJlZ2lzdHJ5IC0gTGV2ZWwgNCBJbnRlZ3JhdGlvbicsICgpID0+IHtcbiAgbGV0IG1jcDtcblxuICBiZWZvcmVBbGwoYXN5bmMgKCkgPT4ge1xuICAgIG1jcCA9IG5ldyBNQ1BIZWxwZXIoJ2xvY2FsaG9zdCcsIDMwMDApO1xuXG4gICAgLy8gV2FpdCBmb3IgTUNQIHNlcnZlciB0byBiZSByZWFkeVxuICAgIHRyeSB7XG4gICAgICBhd2FpdCBtY3Aud2FpdEZvclNlcnZlcig1MDAwKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS53YXJuKCfimqDvuI8gIE1DUCBzZXJ2ZXIgbm90IHJ1bm5pbmcuIFN0YXJ0IGl0IHdpdGg6IGNkIC5zeXN0ZW0vbWNwLXNlcnZlcnMgJiYgbm9kZSBjb21wb25lbnQtcmVnaXN0cnkuanMnKTtcbiAgICAgIGNvbnNvbGUud2Fybign4pqg77iPICBTa2lwcGluZyBNQ1AgaW50ZWdyYXRpb24gdGVzdHMnKTtcbiAgICB9XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdTZXJ2ZXIgQ29ubmVjdGl2aXR5JywgKCkgPT4ge1xuICAgIHRlc3QoJ3Nob3VsZCBjb25uZWN0IHRvIE1DUCBzZXJ2ZXInLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBpc1J1bm5pbmcgPSBhd2FpdCBtY3AuaXNTZXJ2ZXJSdW5uaW5nKCk7XG5cbiAgICAgIGlmICghaXNSdW5uaW5nKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCfij63vuI8gIFNraXBwaW5nIHRlc3QgLSBNQ1Agc2VydmVyIG5vdCBhdmFpbGFibGUnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBleHBlY3QoaXNSdW5uaW5nKS50b0JlKHRydWUpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnQ29tcG9uZW50IFJlZ2lzdHJhdGlvbicsICgpID0+IHtcbiAgICB0ZXN0KCdzaG91bGQgcmVnaXN0ZXIgY29tcG9uZW50IHN1Y2Nlc3NmdWxseScsIGFzeW5jICgpID0+IHtcbiAgICAgIGlmICghYXdhaXQgbWNwLmlzU2VydmVyUnVubmluZygpKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCfij63vuI8gIFNraXBwaW5nIHRlc3QgLSBNQ1Agc2VydmVyIG5vdCBhdmFpbGFibGUnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBjb21wb25lbnQgPSBtY3AuY3JlYXRlTW9ja0NvbXBvbmVudCgndGVzdC1idXR0b24nLCB7XG4gICAgICAgIGNzc05hbWVzcGFjZTogJy5jb21wb25lbnQtdGVzdC1idXR0b24tJyxcbiAgICAgICAganNBUEk6IFsnVGVzdEJ1dHRvbi5pbml0JywgJ1Rlc3RCdXR0b24uZGVzdHJveSddLFxuICAgICAgICBkZXBlbmRlbmNpZXM6IFtdLFxuICAgICAgICBldmVudHM6IFsnYnV0dG9uLWNsaWNrZWQnXVxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IG1jcC5yZWdpc3RlckNvbXBvbmVudChjb21wb25lbnQpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QocmVzdWx0LmNvbXBvbmVudE5hbWUpLnRvQmUoJ3Rlc3QtYnV0dG9uJyk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgbGlzdCByZWdpc3RlcmVkIGNvbXBvbmVudHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBpZiAoIWF3YWl0IG1jcC5pc1NlcnZlclJ1bm5pbmcoKSkge1xuICAgICAgICBjb25zb2xlLmxvZygn4o+t77iPICBTa2lwcGluZyB0ZXN0IC0gTUNQIHNlcnZlciBub3QgYXZhaWxhYmxlJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbWNwLmxpc3RDb21wb25lbnRzKCk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmVEZWZpbmVkKCk7XG4gICAgICBleHBlY3QoQXJyYXkuaXNBcnJheShyZXN1bHQuY29tcG9uZW50cykgfHwgdHlwZW9mIHJlc3VsdC5jb21wb25lbnRzID09PSAnb2JqZWN0JykudG9CZSh0cnVlKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0NvbmZsaWN0IERldGVjdGlvbicsICgpID0+IHtcbiAgICB0ZXN0KCdzaG91bGQgZGV0ZWN0IENTUyBuYW1lc3BhY2UgY29uZmxpY3RzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgaWYgKCFhd2FpdCBtY3AuaXNTZXJ2ZXJSdW5uaW5nKCkpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ+KPre+4jyAgU2tpcHBpbmcgdGVzdCAtIE1DUCBzZXJ2ZXIgbm90IGF2YWlsYWJsZScpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFJlZ2lzdGVyIGZpcnN0IGNvbXBvbmVudFxuICAgICAgY29uc3QgY29tcG9uZW50MSA9IG1jcC5jcmVhdGVNb2NrQ29tcG9uZW50KCdidXR0b24tcHJpbWFyeScsIHtcbiAgICAgICAgY3NzTmFtZXNwYWNlOiAnLmNvbXBvbmVudC1idXR0b24tJyxcbiAgICAgICAganNBUEk6IFsnQnV0dG9uUHJpbWFyeS5pbml0J11cbiAgICAgIH0pO1xuICAgICAgYXdhaXQgbWNwLnJlZ2lzdGVyQ29tcG9uZW50KGNvbXBvbmVudDEpO1xuXG4gICAgICAvLyBUcnkgdG8gcmVnaXN0ZXIgc2Vjb25kIGNvbXBvbmVudCB3aXRoIHNhbWUgbmFtZXNwYWNlXG4gICAgICBjb25zdCBjb21wb25lbnQyID0gbWNwLmNyZWF0ZU1vY2tDb21wb25lbnQoJ2J1dHRvbi1zZWNvbmRhcnknLCB7XG4gICAgICAgIGNzc05hbWVzcGFjZTogJy5jb21wb25lbnQtYnV0dG9uLScsIC8vIENPTkZMSUNUIVxuICAgICAgICBqc0FQSTogWydCdXR0b25TZWNvbmRhcnkuaW5pdCddXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgdmFsaWRhdGlvbiA9IGF3YWl0IG1jcC52YWxpZGF0ZUludGVncmF0aW9uKGNvbXBvbmVudDIubmFtZSk7XG5cbiAgICAgIC8vIFNob3VsZCBkZXRlY3QgdGhlIGNvbmZsaWN0XG4gICAgICBleHBlY3QodmFsaWRhdGlvbi5oYXNDb25mbGljdHMgfHwgdmFsaWRhdGlvbi5zdWNjZXNzID09PSBmYWxzZSkudG9CZSh0cnVlKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBkZXRlY3QgSmF2YVNjcmlwdCBBUEkgY29uZmxpY3RzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgaWYgKCFhd2FpdCBtY3AuaXNTZXJ2ZXJSdW5uaW5nKCkpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ+KPre+4jyAgU2tpcHBpbmcgdGVzdCAtIE1DUCBzZXJ2ZXIgbm90IGF2YWlsYWJsZScpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFJlZ2lzdGVyIGNvbXBvbmVudCB3aXRoIHNwZWNpZmljIEpTIEFQSVxuICAgICAgY29uc3QgY29tcG9uZW50MSA9IG1jcC5jcmVhdGVNb2NrQ29tcG9uZW50KCdmb3JtLXZhbGlkYXRvcicsIHtcbiAgICAgICAgY3NzTmFtZXNwYWNlOiAnLmNvbXBvbmVudC1mb3JtLXZhbGlkYXRvci0nLFxuICAgICAgICBqc0FQSTogWydGb3JtVmFsaWRhdG9yLnZhbGlkYXRlJywgJ0Zvcm1WYWxpZGF0b3IucmVzZXQnXVxuICAgICAgfSk7XG4gICAgICBhd2FpdCBtY3AucmVnaXN0ZXJDb21wb25lbnQoY29tcG9uZW50MSk7XG5cbiAgICAgIC8vIFRyeSB0byByZWdpc3RlciBhbm90aGVyIGNvbXBvbmVudCB3aXRoIG92ZXJsYXBwaW5nIEFQSVxuICAgICAgY29uc3QgY29tcG9uZW50MiA9IG1jcC5jcmVhdGVNb2NrQ29tcG9uZW50KCdmb3JtLWhlbHBlcicsIHtcbiAgICAgICAgY3NzTmFtZXNwYWNlOiAnLmNvbXBvbmVudC1mb3JtLWhlbHBlci0nLFxuICAgICAgICBqc0FQSTogWydGb3JtVmFsaWRhdG9yLnZhbGlkYXRlJ10gLy8gQ09ORkxJQ1QhXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgdmFsaWRhdGlvbiA9IGF3YWl0IG1jcC52YWxpZGF0ZUludGVncmF0aW9uKGNvbXBvbmVudDIubmFtZSk7XG5cbiAgICAgIC8vIFNob3VsZCBkZXRlY3QgdGhlIEFQSSBjb25mbGljdFxuICAgICAgZXhwZWN0KHZhbGlkYXRpb24uaGFzQ29uZmxpY3RzIHx8IHZhbGlkYXRpb24uc3VjY2VzcyA9PT0gZmFsc2UpLnRvQmUodHJ1ZSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgYWxsb3cgbm9uLWNvbmZsaWN0aW5nIGNvbXBvbmVudHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBpZiAoIWF3YWl0IG1jcC5pc1NlcnZlclJ1bm5pbmcoKSkge1xuICAgICAgICBjb25zb2xlLmxvZygn4o+t77iPICBTa2lwcGluZyB0ZXN0IC0gTUNQIHNlcnZlciBub3QgYXZhaWxhYmxlJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgY29tcG9uZW50MSA9IG1jcC5jcmVhdGVNb2NrQ29tcG9uZW50KCdtb2RhbC1kaWFsb2cnLCB7XG4gICAgICAgIGNzc05hbWVzcGFjZTogJy5jb21wb25lbnQtbW9kYWwtZGlhbG9nLScsXG4gICAgICAgIGpzQVBJOiBbJ01vZGFsRGlhbG9nLm9wZW4nLCAnTW9kYWxEaWFsb2cuY2xvc2UnXVxuICAgICAgfSk7XG4gICAgICBhd2FpdCBtY3AucmVnaXN0ZXJDb21wb25lbnQoY29tcG9uZW50MSk7XG5cbiAgICAgIGNvbnN0IGNvbXBvbmVudDIgPSBtY3AuY3JlYXRlTW9ja0NvbXBvbmVudCgndG9vbHRpcC1oZWxwZXInLCB7XG4gICAgICAgIGNzc05hbWVzcGFjZTogJy5jb21wb25lbnQtdG9vbHRpcC1oZWxwZXItJyxcbiAgICAgICAganNBUEk6IFsnVG9vbHRpcEhlbHBlci5zaG93JywgJ1Rvb2x0aXBIZWxwZXIuaGlkZSddXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgdmFsaWRhdGlvbiA9IGF3YWl0IG1jcC52YWxpZGF0ZUludGVncmF0aW9uKGNvbXBvbmVudDIubmFtZSk7XG5cbiAgICAgIC8vIFNob3VsZCBOT1QgaGF2ZSBjb25mbGljdHNcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdJbnRlZ3JhdGlvbiBQbGFuJywgKCkgPT4ge1xuICAgIHRlc3QoJ3Nob3VsZCBnZW5lcmF0ZSBpbnRlZ3JhdGlvbiBwbGFuIGZvciBjb21wb25lbnQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBpZiAoIWF3YWl0IG1jcC5pc1NlcnZlclJ1bm5pbmcoKSkge1xuICAgICAgICBjb25zb2xlLmxvZygn4o+t77iPICBTa2lwcGluZyB0ZXN0IC0gTUNQIHNlcnZlciBub3QgYXZhaWxhYmxlJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgY29tcG9uZW50ID0gbWNwLmNyZWF0ZU1vY2tDb21wb25lbnQoJ2FsZXJ0LWJhbm5lcicsIHtcbiAgICAgICAgY3NzTmFtZXNwYWNlOiAnLmNvbXBvbmVudC1hbGVydC1iYW5uZXItJyxcbiAgICAgICAganNBUEk6IFsnQWxlcnRCYW5uZXIuc2hvdycsICdBbGVydEJhbm5lci5kaXNtaXNzJ11cbiAgICAgIH0pO1xuICAgICAgYXdhaXQgbWNwLnJlZ2lzdGVyQ29tcG9uZW50KGNvbXBvbmVudCk7XG5cbiAgICAgIGNvbnN0IHBsYW4gPSBhd2FpdCBtY3AuZ2V0SW50ZWdyYXRpb25QbGFuKGNvbXBvbmVudC5uYW1lKTtcblxuICAgICAgZXhwZWN0KHBsYW4pLnRvQmVEZWZpbmVkKCk7XG4gICAgICBleHBlY3QocGxhbi5jb21wb25lbnROYW1lIHx8IHBsYW4uY29tcG9uZW50KS50b0JlKGNvbXBvbmVudC5uYW1lKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0NvbnRyYWN0IFZhbGlkYXRpb24nLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIHZhbGlkYXRlIGNvbnRyYWN0IGNvbXBsaWFuY2UnLCBhc3luYyAoKSA9PiB7XG4gICAgICBpZiAoIWF3YWl0IG1jcC5pc1NlcnZlclJ1bm5pbmcoKSkge1xuICAgICAgICBjb25zb2xlLmxvZygn4o+t77iPICBTa2lwcGluZyB0ZXN0IC0gTUNQIHNlcnZlciBub3QgYXZhaWxhYmxlJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgY29udHJhY3RQYXRoID0gJy5zeXN0ZW0vY29udHJhY3RzL2V4YW1wbGUtYnV0dG9uLWNvbnRyYWN0Lm1kJztcbiAgICAgIGNvbnN0IGltcGxlbWVudGF0aW9uUGF0aCA9ICd0ZXN0cy9maXh0dXJlcy9idXR0b24tY29tcG9uZW50LW1vY2suanMnO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBtY3AudmFsaWRhdGVDb250cmFjdChjb250cmFjdFBhdGgsIGltcGxlbWVudGF0aW9uUGF0aCk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmVEZWZpbmVkKCk7XG4gICAgICAvLyBNQ1Agc2hvdWxkIHZhbGlkYXRlIHRoYXQgaW1wbGVtZW50YXRpb24gbWF0Y2hlcyBjb250cmFjdFxuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnUHJlZmxpZ2h0IENoZWNrcycsICgpID0+IHtcbiAgICB0ZXN0KCdzaG91bGQgcnVuIGFsbCA0IHZhbGlkYXRpb24gbGV2ZWxzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgaWYgKCFhd2FpdCBtY3AuaXNTZXJ2ZXJSdW5uaW5nKCkpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ+KPre+4jyAgU2tpcHBpbmcgdGVzdCAtIE1DUCBzZXJ2ZXIgbm90IGF2YWlsYWJsZScpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNvbXBvbmVudCA9IG1jcC5jcmVhdGVNb2NrQ29tcG9uZW50KCdkcm9wZG93bi1tZW51Jywge1xuICAgICAgICBjc3NOYW1lc3BhY2U6ICcuY29tcG9uZW50LWRyb3Bkb3duLW1lbnUtJyxcbiAgICAgICAganNBUEk6IFsnRHJvcGRvd25NZW51LnRvZ2dsZSddXG4gICAgICB9KTtcbiAgICAgIGF3YWl0IG1jcC5yZWdpc3RlckNvbXBvbmVudChjb21wb25lbnQpO1xuXG4gICAgICBjb25zdCBjaGVja3MgPSBhd2FpdCBtY3AucnVuUHJlZmxpZ2h0Q2hlY2tzKGNvbXBvbmVudC5uYW1lKTtcblxuICAgICAgZXhwZWN0KGNoZWNrcykudG9CZURlZmluZWQoKTtcblxuICAgICAgaWYgKGNoZWNrcy5sZXZlbHMpIHtcbiAgICAgICAgLy8gVmVyaWZ5IGFsbCA0IGxldmVscyBhcmUgY2hlY2tlZFxuICAgICAgICBleHBlY3QoY2hlY2tzLmxldmVscykudG9IYXZlUHJvcGVydHkoJ2xldmVsMScpOyAvLyBTeW50YXhcbiAgICAgICAgZXhwZWN0KGNoZWNrcy5sZXZlbHMpLnRvSGF2ZVByb3BlcnR5KCdsZXZlbDInKTsgLy8gVW5pdCBUZXN0c1xuICAgICAgICBleHBlY3QoY2hlY2tzLmxldmVscykudG9IYXZlUHJvcGVydHkoJ2xldmVsMycpOyAvLyBDb250cmFjdFxuICAgICAgICBleHBlY3QoY2hlY2tzLmxldmVscykudG9IYXZlUHJvcGVydHkoJ2xldmVsNCcpOyAvLyBJbnRlZ3JhdGlvblxuICAgICAgfVxuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnU2FuZGJveCBUZXN0aW5nJywgKCkgPT4ge1xuICAgIHRlc3QoJ3Nob3VsZCBjaGVjayBzYW5kYm94IHRlc3Qgc3RhdHVzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgaWYgKCFhd2FpdCBtY3AuaXNTZXJ2ZXJSdW5uaW5nKCkpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ+KPre+4jyAgU2tpcHBpbmcgdGVzdCAtIE1DUCBzZXJ2ZXIgbm90IGF2YWlsYWJsZScpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNvbXBvbmVudCA9IG1jcC5jcmVhdGVNb2NrQ29tcG9uZW50KCdjYXJvdXNlbC1zbGlkZXInKTtcbiAgICAgIGF3YWl0IG1jcC5yZWdpc3RlckNvbXBvbmVudChjb21wb25lbnQpO1xuXG4gICAgICBjb25zdCBzYW5kYm94UmVzdWx0ID0gYXdhaXQgbWNwLnRlc3RJblNhbmRib3goY29tcG9uZW50Lm5hbWUpO1xuXG4gICAgICBleHBlY3Qoc2FuZGJveFJlc3VsdCkudG9CZURlZmluZWQoKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0NvbXBvbmVudCBMaWZlY3ljbGUnLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIG1hcmsgY29tcG9uZW50IGFzIHByb3ZlbiBhZnRlciB2YWxpZGF0aW9uJywgYXN5bmMgKCkgPT4ge1xuICAgICAgaWYgKCFhd2FpdCBtY3AuaXNTZXJ2ZXJSdW5uaW5nKCkpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ+KPre+4jyAgU2tpcHBpbmcgdGVzdCAtIE1DUCBzZXJ2ZXIgbm90IGF2YWlsYWJsZScpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNvbXBvbmVudCA9IG1jcC5jcmVhdGVNb2NrQ29tcG9uZW50KCdzdGF0dXMtYmFkZ2UnLCB7XG4gICAgICAgIGNzc05hbWVzcGFjZTogJy5jb21wb25lbnQtc3RhdHVzLWJhZGdlLScsXG4gICAgICAgIHN0YXR1czogJ3ZhbGlkYXRlZCdcbiAgICAgIH0pO1xuICAgICAgYXdhaXQgbWNwLnJlZ2lzdGVyQ29tcG9uZW50KGNvbXBvbmVudCk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IG1jcC5tYXJrQXNQcm92ZW4oY29tcG9uZW50Lm5hbWUpO1xuXG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlRGVmaW5lZCgpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzIHx8IHJlc3VsdC5zdGF0dXMgPT09ICdwcm92ZW4nKS50b0JlKHRydWUpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnRXhhbXBsZSBCdXR0b24gQ29udHJhY3QgLSBNQ1AgSW50ZWdyYXRpb24nLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIHJlZ2lzdGVyIGV4YW1wbGUtYnV0dG9uIHdpdGhvdXQgY29uZmxpY3RzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgaWYgKCFhd2FpdCBtY3AuaXNTZXJ2ZXJSdW5uaW5nKCkpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ+KPre+4jyAgU2tpcHBpbmcgdGVzdCAtIE1DUCBzZXJ2ZXIgbm90IGF2YWlsYWJsZScpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGV4YW1wbGVCdXR0b24gPSB7XG4gICAgICAgIG5hbWU6ICdleGFtcGxlLWJ1dHRvbicsXG4gICAgICAgIGNzc05hbWVzcGFjZTogJy5jb21wb25lbnQtZXhhbXBsZS1idXR0b24tJyxcbiAgICAgICAganNBUEk6IFsnRXhhbXBsZUJ1dHRvbi5nZXRDb3VudCcsICdFeGFtcGxlQnV0dG9uLnJlc2V0JywgJ0V4YW1wbGVCdXR0b24uZGVzdHJveSddLFxuICAgICAgICBkZXBlbmRlbmNpZXM6IFtdLFxuICAgICAgICBldmVudHM6IFsnYnV0dG9uLWNsaWNrZWQnXSxcbiAgICAgICAgc3RhdHVzOiAnZGV2ZWxvcG1lbnQnXG4gICAgICB9O1xuXG4gICAgICBjb25zdCByZWdpc3RyYXRpb24gPSBhd2FpdCBtY3AucmVnaXN0ZXJDb21wb25lbnQoZXhhbXBsZUJ1dHRvbik7XG4gICAgICBleHBlY3QocmVnaXN0cmF0aW9uLnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG5cbiAgICAgIGNvbnN0IHZhbGlkYXRpb24gPSBhd2FpdCBtY3AudmFsaWRhdGVJbnRlZ3JhdGlvbihleGFtcGxlQnV0dG9uLm5hbWUpO1xuICAgICAgZXhwZWN0KHZhbGlkYXRpb24uc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICB9KTtcbiAgfSk7XG59KTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTUEsU0FBUyxH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