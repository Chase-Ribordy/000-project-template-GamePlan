# Terminal Prompts - Manual Mode Examples

This document shows copy-paste ready terminal prompts generated by orchestrator-exe for manual parallel work coordination. These examples demonstrate the `terminal-prompt-generator` skill output.

---

## Example 1: First-Pass Development - 3 Independent Stories

**Context**: Epic 1-user-management, Wave 1, Strategy 2 (Balanced Parallelism)
**Phase**: First Pass - Core logic only, minimal error handling
**Stories**: 1-1-user-authentication, 1-3-password-reset-flow, 1-6-audit-logging
**Parallelism**: Inter-story (3 terminals, 3 stories)

### Generated Terminal Layout

```
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
PARALLEL WORK SESSION: session_2025-01-15_093012
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Strategy: Balanced Parallelism (2x speedup)
Phase: FIRST PASS - Core logic only, minimal error handling
Epic: 1-user-management
Wave: 1 of 3
Duration Estimate: 2 hours
Coordination Required: Low (independent stories)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
TERMINAL 1 - User Authentication
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Story: 1-1-user-authentication
Title: User Authentication with JWT
Estimated Duration: 2 hours
Dependencies: None - safe to start immediately
Blocks: 1-4-role-based-access-control (notify when complete)

FIRST PASS FOCUS:
  - Core JWT token generation logic
  - Basic user login endpoint (POST /auth/login)
  - Simple password verification (bcrypt)
  - Database: Create users table (id, email, password_hash, created_at)
  - SKIP: Error handling, rate limiting, refresh tokens

COORDINATION NOTES:
  - âš ï¸  You will create the users table schema
  - âš ï¸  Terminal 3 (audit logging) is WAITING for your schema
  - ğŸ“¢ When users table is complete, notify orchestrator

COPY-PASTE COMMAND:
/dev-story 1-1-user-authentication

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
TERMINAL 2 - Password Reset Flow
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Story: 1-3-password-reset-flow
Title: Password Reset via Email
Estimated Duration: 2 hours
Dependencies: None - safe to start immediately
Blocks: None

FIRST PASS FOCUS:
  - Basic password reset token generation
  - Email sending integration (simple template)
  - Reset token validation endpoint
  - Database: Create reset_tokens table (id, user_id, token, expires_at)
  - SKIP: Token expiration logic, rate limiting, email templates

COORDINATION NOTES:
  - âœ… Fully independent - no coordination needed
  - Works on separate database table (reset_tokens)
  - Can complete without waiting for other terminals

COPY-PASTE COMMAND:
/dev-story 1-3-password-reset-flow

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
TERMINAL 3 - Audit Logging
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Story: 1-6-audit-logging
Title: User Action Audit Logging
Estimated Duration: 1 hour
Dependencies: WAITING for Terminal 1 to complete users table schema
Status: â¸ï¸  PAUSED - Resume when T1 completes schema

FIRST PASS FOCUS:
  - Basic audit log middleware
  - Log user actions to database
  - Database: Create audit_logs table (id, user_id, action, timestamp)
  - SKIP: Advanced filtering, log retention, performance optimization

COORDINATION NOTES:
  - âš ï¸  WAIT for Terminal 1 to create users table
  - ğŸ“¢ Estimated resume time: ~30 minutes from now
  - You'll receive notification when schema is ready

COPY-PASTE COMMAND (when ready):
/dev-story 1-6-audit-logging

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
NEXT STEPS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
1. Start Terminal 1 and Terminal 2 simultaneously
2. Terminal 1: Watch for users table schema completion (~30 min)
3. Terminal 1: Notify orchestrator when schema ready
4. Orchestrator will unblock Terminal 3
5. All terminals: Notify when story complete
6. Integration checkpoint when all 3 stories done

MERGE POINT: 12:30 PM (estimated)
  - Brief integration test (15 minutes)
  - Validate no conflicts between stories
  - Then proceed to Wave 2

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
```

---

## Example 2: Second-Pass Development - Error Handling & Contracts

**Context**: Epic 2-payment-processing, Wave 1
**Phase**: Second Pass - Add comprehensive error handling, contracts for MCP validation
**Stories**: 2-1-stripe-integration, 2-2-payment-webhooks
**Parallelism**: Inter-story (2 terminals, coordinated)

### Generated Terminal Layout

```
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
PARALLEL WORK SESSION: session_2025-01-16_140000
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Strategy: Coordinated Parallelism with Contracts
Phase: SECOND PASS - Error handling, validation, contracts
Epic: 2-payment-processing
Wave: 1 of 2
Duration Estimate: 3 hours
Coordination Required: Medium (shared payment domain)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
TERMINAL 1 - Stripe Integration
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Story: 2-1-stripe-integration
Title: Stripe Payment Gateway Integration
Estimated Duration: 3 hours
Dependencies: None (first-pass core logic already exists)
Blocks: None

SECOND PASS FOCUS:
  - Comprehensive error handling (network failures, API errors)
  - Retry logic with exponential backoff
  - Input validation for payment amounts
  - Idempotency key implementation
  - Contract: Define payment-gateway-contract.md for MCP validation

COORDINATION NOTES:
  - ğŸ“ Create payment-gateway-contract.md (Markdown format)
  - ğŸ¤– Orchestrator will convert to YAML for MCP server
  - âš ï¸  Terminal 2 will implement webhook handler - coordinate event types
  - ğŸ“¢ Share Stripe event types list with Terminal 2 when defined

COPY-PASTE COMMAND:
/dev-story 2-1-stripe-integration

CONTRACT TEMPLATE: .bmad/bmm/contracts/payment-gateway-contract.md
Expected MCP validation: Autonomous contract validation via MCP server

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
TERMINAL 2 - Payment Webhooks
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Story: 2-2-payment-webhooks
Title: Stripe Webhook Handler Implementation
Estimated Duration: 2.5 hours
Dependencies: SOFT - coordinate event types with Terminal 1
Status: â–¶ï¸  START IMMEDIATELY (can work in parallel)

SECOND PASS FOCUS:
  - Error handling for webhook signature verification
  - Retry failed webhook processing
  - Idempotent webhook handling
  - Validate webhook payload schema
  - Contract: Define webhook-handler-contract.md

COORDINATION NOTES:
  - âš ï¸  Coordinate with Terminal 1 on Stripe event types
  - Wait for T1's event type list (estimated 30 min) before finalizing handlers
  - ğŸ“ Create webhook-handler-contract.md
  - ğŸ¤– Both contracts will be validated together by MCP server

COPY-PASTE COMMAND:
/dev-story 2-2-payment-webhooks

CONTRACT TEMPLATE: .bmad/bmm/contracts/webhook-handler-contract.md
Expected MCP validation: Autonomous contract validation via MCP server

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
CONTRACT COORDINATION
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Phase: SECOND PASS requires contract definition and validation

Step 1: Both terminals create Markdown contracts
  - T1: payment-gateway-contract.md
  - T2: webhook-handler-contract.md

Step 2: Orchestrator converts to YAML via contract-orchestrator skill
  - Output: payment-gateway-contract.yaml
  - Output: webhook-handler-contract.yaml

Step 3: MCP server validates contracts (autonomous mode)
  - Verifies payment gateway integration points
  - Verifies webhook handler completeness
  - Checks for contract conflicts

Step 4: Integration merge point
  - Both stories complete
  - Contracts validated
  - Integration tests run
  - Ready for production deployment

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
NEXT STEPS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
1. Start both terminals simultaneously
2. T1: Define Stripe event types within 30 minutes
3. T1: Share event types with orchestrator
4. Orchestrator: Broadcast to T2
5. T2: Implement webhook handlers based on event types
6. Both: Complete contract definitions
7. Orchestrator: Convert contracts to YAML and trigger MCP validation
8. Integration checkpoint when validation passes

MERGE POINT: 5:00 PM (estimated)
  - Contract validation (autonomous)
  - Integration tests
  - Deploy to staging

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
```

---

## Example 3: Third-Pass Development - Intra-Story Parallelism

**Context**: Story 3-5-dashboard-redesign (large story)
**Phase**: Third Pass - UX enhancement, performance optimization
**Parallelism**: Intra-story (3 terminals, 1 story split into tasks)

### Generated Terminal Layout

```
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
PARALLEL WORK SESSION: session_2025-01-17_100000
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Strategy: Intra-Story Task Parallelism
Phase: THIRD PASS - Polish, UX enhancement, performance
Story: 3-5-dashboard-redesign (LARGE - split into parallel tasks)
Duration Estimate: 4 hours
Coordination Required: High (shared UI components)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
TERMINAL 1 - Task 1: Dashboard Data Visualization
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Story: 3-5-dashboard-redesign
Task: data-visualization-charts
Estimated Duration: 3 hours

THIRD PASS FOCUS:
  - Implement interactive charts (Chart.js)
  - Real-time data updates via WebSocket
  - Responsive chart sizing
  - Accessibility: Screen reader support for chart data
  - Performance: Virtualization for large datasets

COORDINATION NOTES:
  - âš ï¸  Shares Dashboard component with T2 and T3
  - ğŸ“ Use DashboardChartsSection.tsx (new component)
  - ğŸ”„ Coordinate merge with T2 (layout) and T3 (filters)
  - ğŸ“¢ Notify when component interface defined (~1 hour)

COPY-PASTE COMMAND:
/dev-story 3-5-dashboard-redesign --task data-visualization-charts

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
TERMINAL 2 - Task 2: Dashboard Layout & Responsive Design
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Story: 3-5-dashboard-redesign
Task: responsive-layout-grid
Estimated Duration: 2.5 hours

THIRD PASS FOCUS:
  - CSS Grid responsive layout
  - Mobile-first design
  - Dark mode support
  - Animation transitions
  - Accessibility: Keyboard navigation

COORDINATION NOTES:
  - âš ï¸  Defines main Dashboard.tsx structure
  - ğŸ“ Create layout slots for T1 (charts) and T3 (filters)
  - ğŸ”„ T1 and T3 will plug into your layout
  - ğŸ“¢ Share layout prop interface early (~30 min)

COPY-PASTE COMMAND:
/dev-story 3-5-dashboard-redesign --task responsive-layout-grid

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
TERMINAL 3 - Task 3: Advanced Filtering & Search
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Story: 3-5-dashboard-redesign
Task: advanced-filters-search
Estimated Duration: 2 hours

THIRD PASS FOCUS:
  - Multi-criteria filtering UI
  - Real-time search with debounce
  - Filter persistence (localStorage)
  - Accessibility: Filter controls keyboard accessible
  - Performance: Memoized filter computations

COORDINATION NOTES:
  - âš ï¸  Integrates with T1 (filters affect chart data)
  - âš ï¸  Plugs into T2's layout
  - ğŸ“ Use DashboardFilters.tsx (new component)
  - ğŸ”„ Share filter state interface with T1
  - ğŸ“¢ Notify when filter interface ready (~45 min)

COPY-PASTE COMMAND:
/dev-story 3-5-dashboard-redesign --task advanced-filters-search

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
INTRA-STORY COORDINATION PROTOCOL
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
This is INTRA-STORY parallelism - all terminals work on the SAME story.

Interface Definition Phase (First Hour):
  1. T2 defines Dashboard.tsx layout structure and prop interfaces (30 min)
  2. T1 defines DashboardChartsSection props (1 hour)
  3. T3 defines DashboardFilters props and state interface (45 min)
  4. Orchestrator coordinates interface alignment

Parallel Development Phase (Next 2 hours):
  1. All terminals implement their components independently
  2. Use agreed-upon interfaces
  3. Mock data for testing if needed

Integration Phase (Final Hour):
  1. Merge all components into Dashboard.tsx
  2. Wire up filter â†’ chart data flow
  3. Test responsive layout with all components
  4. Accessibility testing
  5. Performance profiling

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
MERGE STRATEGY
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
File: src/components/Dashboard.tsx
Merge Approach: Component composition

T2 creates base:
  Dashboard.tsx (main layout shell)

T1 merges in:
  import DashboardChartsSection from './DashboardChartsSection'
  <DashboardChartsSection data={filteredData} />

T3 merges in:
  import DashboardFilters from './DashboardFilters'
  <DashboardFilters onFilterChange={handleFilterChange} />

Conflict Zones:
  - State management (filters affect charts)
  - Props threading through layout
  - Import statements

Resolution: Coordinate via orchestrator at merge point

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
NEXT STEPS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
1. T2: Start immediately - define layout structure
2. T1 & T3: Start in parallel, wait 30 min for T2's interface
3. All: Share interface definitions via orchestrator
4. All: Implement components independently (2 hours)
5. Merge point at 2:00 PM
6. Integration testing (1 hour)
7. Story complete and ready for review

MERGE POINT: 2:00 PM (estimated)
  - Component integration
  - Resolve merge conflicts
  - Integration & accessibility testing
  - Performance profiling

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
```

---

## Example 4: Mixed-Mode - Manual Start, Autonomous Continuation

**Context**: Epic 4-api-refactoring, transitioning to autonomous mode
**Phase**: Second Pass - Refactoring with contract validation
**Mode Transition**: Manual â†’ Autonomous after first story

### Generated Terminal Layout (Initial Manual Phase)

```
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
PARALLEL WORK SESSION: session_2025-01-18_090000
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Strategy: Mixed Mode - Manual Start, Autonomous Continuation
Phase: SECOND PASS - Refactoring with patterns established
Epic: 4-api-refactoring
Mode: MANUAL (will transition to AUTONOMOUS after Story 4-1)
Duration Estimate: 6 hours total
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
TERMINAL 1 - Establish Refactoring Pattern (Manual)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Story: 4-1-refactor-user-endpoints
Title: Refactor User API Endpoints
Mode: MANUAL (establishes pattern for autonomous continuation)
Estimated Duration: 2 hours

SECOND PASS FOCUS:
  - Refactor to RESTful conventions
  - Add comprehensive error handling
  - Create contract: user-api-contract.md
  - Document refactoring pattern for other endpoints

PATTERN TO ESTABLISH:
  1. Endpoint naming: /api/v1/users/{id} (RESTful)
  2. Error responses: Standardized JSON schema
  3. Validation: Joi schemas for all inputs
  4. Testing: Integration tests for all endpoints
  5. Contract: Define request/response schemas

âš ï¸  THIS IS THE TEMPLATE STORY
  - Autonomous mode will replicate this pattern for stories 4-2 through 4-6
  - Be thorough - this becomes the reference implementation
  - Document decisions in story file

COPY-PASTE COMMAND:
/dev-story 4-1-refactor-user-endpoints

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
TERMINAL 2 - Reserved for Autonomous Mode
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Status: â¸ï¸  WAITING for Story 4-1 pattern completion

Once Story 4-1 complete:
  - Orchestrator analyzes refactoring pattern
  - Generates YAML contract for autonomous execution
  - MCP server validates approach
  - Terminal 2 switches to AUTONOMOUS mode
  - Stories 4-2 through 4-6 auto-executed following pattern

Estimated autonomous execution: 4-5 stories in 4 hours

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
AUTONOMOUS TRANSITION CHECKPOINT
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
After Story 4-1 completes:

1. Operator reviews refactoring pattern
2. Orchestrator extracts pattern as contract
3. Contract converted to YAML via contract-orchestrator skill
4. MCP server validates contract
5. Operator approves autonomous mode
6. Stories 4-2 through 4-6 executed autonomously

Decision Point: Continue autonomous or revert to manual?
  - If pattern is clear and tests pass â†’ Autonomous
  - If pattern needs adjustment â†’ Stay manual

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
NEXT STEPS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
1. Start Terminal 1 - Story 4-1 (manual)
2. Establish refactoring pattern thoroughly
3. Complete Story 4-1 and mark DONE
4. Orchestrator analyzes pattern
5. Operator reviews and approves autonomous continuation
6. Terminal 2 activates in autonomous mode
7. Remaining stories auto-executed

DECISION POINT: ~11:00 AM (after Story 4-1 complete)
  - Review pattern quality
  - Approve autonomous mode
  - Or continue manual if pattern unclear

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
```

---

## Usage Notes

### How These Prompts Are Generated

1. Operator invokes `/orchestrator-exe` after sprint planning
2. Orchestrator-exe analyzes `sprint-status.yaml`
3. `sprint-batch-analyzer` skill identifies parallelizable stories
4. `decision_support` skill recommends manual vs autonomous mode
5. `terminal-prompt-generator` skill creates these formatted prompts
6. Operator copies prompts to respective terminals

### Customization

Operators can request custom prompt formats:
- Simplified (less detail, just commands)
- Detailed (all coordination notes, as shown above)
- Contract-focused (second-pass emphasis on contracts)
- Phase-specific (first/second/third-pass templates)

### Coordination Protocol

- **Manual mode**: Operator copy-pastes commands, monitors coordination
- **Autonomous mode**: Orchestrator executes commands via MCP contracts
- **Mixed mode**: Start manual (establish pattern), continue autonomous

---

## See Also

- `yaml-contracts-autonomous.md` - Autonomous mode contract examples
- `activation-scenarios.md` - Full workflow examples
- `coordination-log-example.yaml` - Behind-the-scenes coordination tracking
