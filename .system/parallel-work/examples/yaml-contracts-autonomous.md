# YAML Contracts - Autonomous Mode Examples

This document demonstrates YAML contracts generated by the `contract-orchestrator` skill for autonomous parallel work execution. These contracts are validated by MCP servers and enable the orchestrator-exe to execute stories without manual intervention.

---

## Overview: Markdown to YAML Contract Flow

```
Operator/Dev writes:           Orchestrator processes:        MCP validates:
markdown-contract.md    →      yaml-contract.yaml      →      ✓ Contract valid
                                                              ✓ Ready to execute
```

**Process:**
1. Developer creates Markdown contract (human-readable)
2. `contract-orchestrator` skill converts to YAML (machine-readable)
3. MCP server validates contract structure and completeness
4. Orchestrator-exe executes autonomously based on validated contract

---

## Example 1: Component Integration Contract (Second-Pass)

### Source: Markdown Contract

**File**: `.bmad/bmm/contracts/payment-gateway-integration.md`

```markdown
# Payment Gateway Integration Contract

## Component
**ID**: payment-gateway-service
**Type**: Backend Service
**Phase**: Second Pass - Error Handling & Integration

## Integration Points

### Inputs
- **User Payment Request**
  - Source: Frontend payment form
  - Format: JSON { amount: number, currency: string, paymentMethod: string }
  - Validation: Joi schema validation

### Outputs
- **Payment Confirmation**
  - Destination: Frontend confirmation page
  - Format: JSON { transactionId: string, status: string, timestamp: string }
  - Success codes: 200, 201

- **Payment Failed Response**
  - Destination: Frontend error handler
  - Format: JSON { error: string, code: string, retry: boolean }
  - Error codes: 400, 402, 500

### External Dependencies
- **Stripe API**
  - Endpoint: https://api.stripe.com/v1/charges
  - Authentication: API Key (environment variable)
  - Retry strategy: Exponential backoff, 3 attempts

## Error Handling
- Network failures: Retry with exponential backoff
- Invalid payment method: Return 400 with descriptive error
- Insufficient funds: Return 402 with retry=false
- Stripe API errors: Log and return 500

## Testing Requirements
- Unit tests: Payment processing logic
- Integration tests: Stripe API integration (test mode)
- Contract tests: Request/response validation

## Acceptance Criteria
- [ ] All error cases handled gracefully
- [ ] Stripe integration working in test mode
- [ ] Contract tests passing
- [ ] Idempotency implemented (duplicate requests handled)
```

### Generated: YAML Contract

**File**: `.system/parallel-work/contracts/payment-gateway-integration.yaml`
**Generated by**: `contract-orchestrator` skill

```yaml
# Auto-generated YAML Contract from Markdown
# Source: .bmad/bmm/contracts/payment-gateway-integration.md
# Generated: 2025-01-16T14:30:00Z
# Generator: orchestrator-exe/contract-orchestrator skill

contract_id: "payment-gateway-integration"
contract_version: "1.0.0"
phase: "second_pass"
component:
  id: "payment-gateway-service"
  type: "backend_service"
  language: "typescript"
  framework: "express"

integration_points:
  inputs:
    - input_id: "user_payment_request"
      source: "frontend_payment_form"
      format: "json"
      schema:
        type: "object"
        required: ["amount", "currency", "paymentMethod"]
        properties:
          amount:
            type: "number"
            minimum: 0.01
          currency:
            type: "string"
            enum: ["USD", "EUR", "GBP"]
          paymentMethod:
            type: "string"
      validation:
        library: "joi"
        schema_file: "src/validators/payment.validator.ts"

  outputs:
    - output_id: "payment_confirmation"
      destination: "frontend_confirmation_page"
      format: "json"
      schema:
        type: "object"
        required: ["transactionId", "status", "timestamp"]
        properties:
          transactionId:
            type: "string"
            pattern: "^txn_[a-zA-Z0-9]{16}$"
          status:
            type: "string"
            enum: ["success", "pending"]
          timestamp:
            type: "string"
            format: "date-time"
      http_status_codes: [200, 201]

    - output_id: "payment_failed_response"
      destination: "frontend_error_handler"
      format: "json"
      schema:
        type: "object"
        required: ["error", "code", "retry"]
        properties:
          error:
            type: "string"
          code:
            type: "string"
          retry:
            type: "boolean"
      http_status_codes: [400, 402, 500]

  external_dependencies:
    - dependency_id: "stripe_api"
      service: "Stripe Payment API"
      endpoint: "https://api.stripe.com/v1/charges"
      authentication:
        type: "api_key"
        source: "environment_variable"
        variable_name: "STRIPE_API_KEY"
      retry_strategy:
        type: "exponential_backoff"
        max_attempts: 3
        initial_delay_ms: 1000
        max_delay_ms: 10000

error_handling:
  strategies:
    - error_type: "network_failure"
      handling: "retry_exponential_backoff"
      max_retries: 3
      fallback: "return_500_service_unavailable"

    - error_type: "invalid_payment_method"
      handling: "validate_and_reject"
      http_status: 400
      response_message: "Invalid payment method. Accepted: card, bank_account"

    - error_type: "insufficient_funds"
      handling: "reject_no_retry"
      http_status: 402
      response_schema:
        error: "Insufficient funds"
        code: "INSUFFICIENT_FUNDS"
        retry: false

    - error_type: "stripe_api_error"
      handling: "log_and_return_error"
      http_status: 500
      logging:
        level: "error"
        fields: ["stripe_error_code", "stripe_message", "request_id"]

testing_requirements:
  unit_tests:
    - test_suite: "payment_processing_logic"
      file: "tests/unit/payment.service.test.ts"
      coverage_minimum: "90%"
      test_cases:
        - "Valid payment processing"
        - "Invalid amount handling"
        - "Currency validation"
        - "Payment method validation"

  integration_tests:
    - test_suite: "stripe_api_integration"
      file: "tests/integration/stripe.integration.test.ts"
      mode: "stripe_test_mode"
      test_cases:
        - "Successful payment charge"
        - "Failed payment (insufficient funds)"
        - "Network retry logic"
        - "Idempotency with duplicate requests"

  contract_tests:
    - test_suite: "request_response_validation"
      file: "tests/contract/payment-gateway.contract.test.ts"
      framework: "pact"
      validates:
        - "Input schema validation"
        - "Output schema validation"
        - "Error response formats"

acceptance_criteria:
  - criterion: "error_handling_comprehensive"
    description: "All error cases handled gracefully"
    validation: "Manual review of error handling code"
    status: "pending"

  - criterion: "stripe_integration_working"
    description: "Stripe integration working in test mode"
    validation: "Integration tests passing"
    status: "pending"

  - criterion: "contract_tests_passing"
    description: "Contract tests passing"
    validation: "Automated test suite"
    status: "pending"

  - criterion: "idempotency_implemented"
    description: "Duplicate requests handled via idempotency keys"
    validation: "Integration test for duplicate request"
    status: "pending"

# MCP Validation Metadata
mcp_validation:
  validator: "component-integration-validator"
  validation_rules:
    - rule: "all_integration_points_defined"
      status: "valid"
    - rule: "error_handling_comprehensive"
      status: "valid"
    - rule: "testing_requirements_complete"
      status: "valid"
    - rule: "acceptance_criteria_measurable"
      status: "valid"

  validation_timestamp: "2025-01-16T14:30:15Z"
  validation_result: "VALID"
  ready_for_autonomous_execution: true

# Autonomous Execution Plan (generated by orchestrator-exe)
autonomous_execution:
  execution_mode: "autonomous"
  estimated_duration: "2.5 hours"
  terminal_assignment: "T1"

  steps:
    - step: 1
      action: "implement_error_handling"
      duration: "1 hour"
      validation: "unit_tests_passing"

    - step: 2
      action: "stripe_api_integration"
      duration: "1 hour"
      validation: "integration_tests_passing"

    - step: 3
      action: "contract_test_implementation"
      duration: "30 minutes"
      validation: "contract_tests_passing"

  success_criteria:
    - "All acceptance criteria status = completed"
    - "All tests passing"
    - "No manual intervention required"

  rollback_plan:
    - "If tests fail, revert to manual mode"
    - "Notify operator of failure reason"
    - "Preserve work for manual review"
```

---

## Example 2: Parallel Story Execution Contract

### Generated YAML Contract for Batch Execution

**File**: `.system/parallel-work/contracts/epic-1-wave-1-batch.yaml`
**Generated by**: `contract-orchestrator` skill for parallel story coordination

```yaml
# Parallel Story Execution Contract
# Epic: 1-user-management
# Wave: 1 (Independent stories batch)
# Generated: 2025-01-15T09:00:00Z

contract_id: "epic-1-wave-1-parallel-batch"
contract_version: "1.0.0"
execution_mode: "autonomous_parallel"
phase: "first_pass"

epic:
  epic_id: "1-user-management"
  title: "User Management System"
  wave: 1
  total_waves: 3

stories:
  - story_id: "1-1-user-authentication"
    terminal: "T1"
    mode: "autonomous"
    estimated_duration: "2 hours"
    dependencies: []

    autonomous_contract:
      component_id: "user-auth-service"
      integration_points:
        - input: "POST /auth/login"
          validation: "email and password required"
        - output: "JWT token"
          format: "Bearer {token}"

      error_handling:
        - "Invalid credentials → 401"
        - "Missing fields → 400"

      testing:
        - unit_tests: "auth.service.test.ts"
        - integration_tests: "auth.integration.test.ts"

      acceptance:
        - "User can login with valid credentials"
        - "Invalid credentials rejected"
        - "JWT token generated correctly"

  - story_id: "1-3-password-reset-flow"
    terminal: "T2"
    mode: "autonomous"
    estimated_duration: "2 hours"
    dependencies: []

    autonomous_contract:
      component_id: "password-reset-service"
      integration_points:
        - input: "POST /auth/reset-request"
          validation: "email required"
        - output: "Reset email sent"
          external: "email service"

      error_handling:
        - "Invalid email → 400"
        - "Email service failure → retry 3x"

      testing:
        - unit_tests: "password-reset.service.test.ts"
        - integration_tests: "email.integration.test.ts"

      acceptance:
        - "Reset email sent to valid email"
        - "Invalid email rejected"
        - "Reset token expires after 1 hour"

  - story_id: "1-6-audit-logging"
    terminal: "T3"
    mode: "autonomous"
    estimated_duration: "1 hour"
    dependencies: ["1-1-user-authentication"]  # Needs users table from 1-1
    wait_strategy: "poll_dependency_completion"

    autonomous_contract:
      component_id: "audit-logging-middleware"
      integration_points:
        - input: "HTTP request middleware"
          captures: "user_id, action, timestamp"
        - output: "Audit log database entry"

      error_handling:
        - "Database write failure → queue for retry"
        - "Missing user context → log as anonymous"

      testing:
        - unit_tests: "audit.middleware.test.ts"
        - integration_tests: "audit.integration.test.ts"

      acceptance:
        - "User actions logged to database"
        - "Audit logs queryable by user_id"
        - "Anonymous actions logged separately"

coordination:
  strategy: "balanced_parallelism"

  conflict_zones:
    - zone: "database_schema"
      affected_stories: ["1-1-user-authentication", "1-6-audit-logging"]
      resolution: "1-1 creates users table first, 1-6 waits"
      wait_condition: "1-1 milestone: database_schema_complete"

  milestones:
    - milestone_id: "database_schema_complete"
      story: "1-1-user-authentication"
      trigger: "Users table created"
      broadcasts_to: ["1-6-audit-logging"]

  merge_points:
    - merge_id: "wave_1_integration"
      stories: ["1-1-user-authentication", "1-3-password-reset-flow", "1-6-audit-logging"]
      trigger: "All stories complete"
      actions:
        - "Run integration test suite"
        - "Validate no schema conflicts"
        - "Mark wave 1 complete"

autonomous_execution_plan:
  # Orchestrator-exe will execute this automatically

  phase_1_initialization:
    - action: "Start T1 (1-1) and T2 (1-3) immediately"
      reason: "No dependencies, fully independent"
    - action: "Wait T3 (1-6) for T1 milestone"
      reason: "Depends on users table from T1"

  phase_2_monitor_progress:
    - action: "Poll T1 for database_schema_complete milestone"
      interval: "5 minutes"
    - action: "When T1 milestone reached, start T3"
      notification: "Broadcast users table schema to T3"

  phase_3_merge_point:
    - action: "Wait for all stories completion"
    - action: "Run integration tests"
    - action: "Update sprint-status.yaml via /story-done"
    - action: "Log coordination results"

mcp_validation:
  validator: "parallel-story-batch-validator"
  validation_rules:
    - rule: "all_stories_have_autonomous_contracts"
      status: "valid"
    - rule: "dependencies_resolvable"
      status: "valid"
    - rule: "conflict_zones_have_resolution_strategy"
      status: "valid"
    - rule: "merge_points_defined"
      status: "valid"

  validation_result: "VALID"
  ready_for_autonomous_execution: true

operator_notifications:
  # Orchestrator will notify operator at these points
  - event: "session_start"
    message: "Starting autonomous execution of 3 stories (Wave 1)"

  - event: "dependency_wait"
    message: "T3 waiting for T1 to complete users table"

  - event: "milestone_reached"
    message: "T1 completed database schema, T3 unblocked"

  - event: "merge_point"
    message: "All stories complete, running integration tests"

  - event: "session_complete"
    message: "Wave 1 complete - 3 stories done in 2h 15m (2.3x speedup)"

success_criteria:
  - "All 3 stories marked DONE in sprint-status.yaml"
  - "Integration tests passing"
  - "No conflicts in merge point"
  - "Actual duration within 20% of estimate"

rollback_strategy:
  - trigger: "Any story fails tests"
  - action: "Pause autonomous execution"
  - action: "Notify operator with failure details"
  - action: "Switch to manual mode for debugging"
  - action: "Preserve partial work for recovery"
```

---

## Example 3: Refactoring Pattern Contract (Third-Pass)

### Generated YAML Contract for Pattern-Based Autonomous Refactoring

**File**: `.system/parallel-work/contracts/api-refactoring-pattern.yaml`
**Generated by**: `contract-orchestrator` skill after analyzing Story 4-1 (template story)

```yaml
# Refactoring Pattern Contract
# Extracted from Story 4-1 (template) for autonomous replication
# Generated: 2025-01-18T11:00:00Z

contract_id: "api-refactoring-pattern"
contract_version: "1.0.0"
execution_mode: "autonomous_pattern_replication"
phase: "second_pass"

# Pattern extracted from template story
pattern:
  template_story: "4-1-refactor-user-endpoints"
  pattern_type: "api_refactoring_to_restful"
  applicability: "All stories 4-2 through 4-6 in Epic 4-api-refactoring"

# Refactoring steps (extracted from successful Story 4-1)
refactoring_steps:
  - step: 1
    action: "rename_endpoints_to_restful_convention"
    pattern:
      old: "/getUserById"
      new: "/api/v1/users/{id}"
      method: "GET"

    template_from_story_4_1:
      - "Renamed /getUserById → /api/v1/users/:id"
      - "Renamed /updateUser → /api/v1/users/:id (PUT)"
      - "Renamed /deleteUser → /api/v1/users/:id (DELETE)"
      - "Renamed /createUser → /api/v1/users (POST)"

    apply_to_stories:
      - story: "4-2-refactor-product-endpoints"
        endpoints:
          - "/getProductById → /api/v1/products/{id}"
          - "/updateProduct → /api/v1/products/{id} (PUT)"
          - "/deleteProduct → /api/v1/products/{id} (DELETE)"
          - "/createProduct → /api/v1/products (POST)"

  - step: 2
    action: "add_comprehensive_error_handling"
    pattern:
      validation_errors: "Return 400 with JSON schema"
      not_found: "Return 404 with descriptive message"
      server_errors: "Return 500 with logged error"

    template_from_story_4_1:
      error_response_schema:
        type: "object"
        properties:
          error:
            type: "string"
          code:
            type: "string"
          details:
            type: "object"

    apply_to_all_stories: true

  - step: 3
    action: "add_request_validation"
    pattern:
      library: "joi"
      location: "src/validators/{resource}.validator.ts"

    template_from_story_4_1:
      validator_file: "src/validators/user.validator.ts"
      schema_pattern: |
        export const createUserSchema = Joi.object({
          email: Joi.string().email().required(),
          name: Joi.string().min(2).required()
        })

    apply_to_stories:
      - story: "4-2-refactor-product-endpoints"
        validator_file: "src/validators/product.validator.ts"
      - story: "4-3-refactor-order-endpoints"
        validator_file: "src/validators/order.validator.ts"

  - step: 4
    action: "add_integration_tests"
    pattern:
      test_file: "tests/integration/{resource}.integration.test.ts"
      test_cases:
        - "Create resource - valid input"
        - "Create resource - invalid input (400)"
        - "Get resource - exists (200)"
        - "Get resource - not found (404)"
        - "Update resource - valid (200)"
        - "Delete resource - success (204)"

    template_from_story_4_1:
      test_file: "tests/integration/user.integration.test.ts"
      coverage: "100% of endpoints"

    apply_to_all_stories: true

# Autonomous execution for remaining stories
autonomous_stories:
  - story_id: "4-2-refactor-product-endpoints"
    resource: "product"
    endpoints_to_refactor: 4
    estimated_duration: "1.5 hours"
    autonomous_contract:
      apply_pattern: "api_refactoring_pattern"
      customize:
        resource_name: "product"
        validator_fields: ["name", "price", "sku"]

  - story_id: "4-3-refactor-order-endpoints"
    resource: "order"
    endpoints_to_refactor: 6
    estimated_duration: "2 hours"
    autonomous_contract:
      apply_pattern: "api_refactoring_pattern"
      customize:
        resource_name: "order"
        validator_fields: ["userId", "items", "totalAmount"]

  - story_id: "4-4-refactor-inventory-endpoints"
    resource: "inventory"
    endpoints_to_refactor: 3
    estimated_duration: "1 hour"
    autonomous_contract:
      apply_pattern: "api_refactoring_pattern"
      customize:
        resource_name: "inventory"
        validator_fields: ["productId", "quantity"]

coordination:
  parallelism: "full_parallel"
  terminals: 3
  strategy: "pattern_replication_autonomous"

  stories_per_wave:
    wave_1: ["4-2-refactor-product-endpoints", "4-3-refactor-order-endpoints", "4-4-refactor-inventory-endpoints"]

  conflict_risk: "none"
  reason: "Different resources, no shared code"

mcp_validation:
  validator: "pattern-replication-validator"
  validation_rules:
    - rule: "pattern_extracted_from_template"
      status: "valid"
      source: "Story 4-1 completed successfully"

    - rule: "pattern_applicable_to_target_stories"
      status: "valid"
      verified: "All stories refactor API endpoints with same structure"

    - rule: "customization_parameters_defined"
      status: "valid"
      parameters: ["resource_name", "validator_fields"]

  validation_result: "VALID"
  ready_for_autonomous_execution: true
  confidence_score: "95%"  # High confidence due to successful template

autonomous_execution_plan:
  execution_strategy: "parallel_pattern_replication"

  phase_1_setup:
    - "Load pattern contract from Story 4-1"
    - "Customize for each story (resource names, fields)"
    - "Generate story-specific contracts"

  phase_2_parallel_execution:
    - "T1 executes Story 4-2 (product endpoints)"
    - "T2 executes Story 4-3 (order endpoints)"
    - "T3 executes Story 4-4 (inventory endpoints)"
    - "All terminals apply same refactoring pattern"

  phase_3_validation:
    - "Each story runs integration tests"
    - "Verify pattern applied correctly"
    - "All tests must pass"

  phase_4_completion:
    - "Mark all stories DONE if tests pass"
    - "Generate completion report"
    - "Notify operator of autonomous batch completion"

operator_notifications:
  - event: "pattern_extraction_complete"
    message: "Pattern extracted from Story 4-1, ready for autonomous replication"

  - event: "autonomous_batch_start"
    message: "Starting autonomous execution of 3 stories using pattern"

  - event: "story_complete"
    message: "Story {story_id} complete - pattern applied successfully"

  - event: "batch_complete"
    message: "All 3 stories complete in 2h (vs 4.5h sequential) - 2.25x speedup"

success_criteria:
  - "All stories follow refactoring pattern consistently"
  - "All integration tests passing"
  - "No manual intervention required"
  - "Code quality matches template story"

quality_gates:
  - gate: "pattern_consistency"
    validation: "Code review shows consistent pattern application"

  - gate: "test_coverage"
    validation: "100% endpoint coverage in integration tests"

  - gate: "no_regressions"
    validation: "All existing tests still passing"
```

---

## Usage Notes

### When Autonomous Mode Is Appropriate

1. **Second-pass with established patterns** - Error handling, refactoring with templates
2. **Component integration with clear contracts** - Well-defined interfaces
3. **Pattern replication** - Template story establishes pattern, others follow
4. **High confidence validation** - MCP can verify correctness

### When to Stay in Manual Mode

1. **First-pass of novel features** - Uncertain patterns, exploration needed
2. **Complex architectural decisions** - Human judgment required
3. **Low confidence contracts** - Incomplete specifications
4. **High-risk changes** - Production-critical code

### Contract Quality Indicators

- **High quality**: Complete integration points, error handling, testing, acceptance criteria
- **Medium quality**: Some ambiguity, manual review recommended
- **Low quality**: Missing critical details, stay in manual mode

### MCP Validation Process

1. Contract submitted to MCP server
2. Validator checks completeness, consistency
3. Confidence score calculated (0-100%)
4. If score > 85%: Approve autonomous execution
5. If score < 85%: Recommend manual mode or contract improvement

---

## See Also

- `terminal-prompts-manual.md` - Manual mode prompt examples
- `activation-scenarios.md` - End-to-end workflow examples
- `contract-orchestrator.md` - Skill documentation for contract generation
